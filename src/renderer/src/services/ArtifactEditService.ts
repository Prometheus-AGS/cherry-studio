import { loggerService } from '@logger'

import AiProvider from '../aiCore'
import type { ArtifactVersion, Assistant, EditRequest, EditResponse, ReactArtifact } from '../types'
import { ArtifactVersionManager } from './ArtifactVersionManager'
import { getProviderByModel } from './AssistantService'
import { ComponentCompiler } from './ComponentCompiler'

const logger = loggerService.withContext('ArtifactEditService')

/**
 * Service for handling LLM-based conversational editing of React artifacts
 * Integrates with Cherry Studio's AI core to provide intelligent code modifications
 */
export class ArtifactEditService {
  private static instance: ArtifactEditService | null = null
  private versionManager: ArtifactVersionManager
  private compiler: ComponentCompiler

  private constructor() {
    this.versionManager = ArtifactVersionManager.getInstance()
    this.compiler = ComponentCompiler.getInstance()
  }

  public static getInstance(): ArtifactEditService {
    if (!ArtifactEditService.instance) {
      ArtifactEditService.instance = new ArtifactEditService()
    }
    return ArtifactEditService.instance
  }

  /**
   * Process an edit request using LLM to modify React artifact code
   */
  public async processEditRequest(request: EditRequest, assistant: Assistant): Promise<EditResponse> {
    try {
      logger.info('Processing edit request', {
        artifactId: request.artifactId,
        version: request.currentVersion,
        instruction: request.editInstruction.substring(0, 100) + '...'
      })

      // Get current artifact version
      const currentVersion = await this.versionManager.getVersion(request.artifactId, request.currentVersion)

      if (!currentVersion) {
        return {
          success: false,
          explanation: 'Artifact version not found',
          changesApplied: [],
          errors: ['The specified artifact version could not be found']
        }
      }

      // Build edit prompt for LLM
      const editPrompt = this.buildEditPrompt(currentVersion, request)

      // Get LLM response using AI core
      const llmResponse = await this.generateEdit(editPrompt, assistant)

      // Parse the LLM response
      const parsedResponse = this.parseEditResponse(llmResponse)

      if (!parsedResponse.newCode) {
        return {
          success: false,
          explanation: 'LLM failed to generate valid code',
          changesApplied: [],
          errors: ['No valid code was generated by the LLM']
        }
      }

      // Validate the generated code
      const validationResult = await this.validateCode(parsedResponse.newCode)

      if (!validationResult.isValid) {
        return {
          success: false,
          explanation: 'Generated code failed validation',
          changesApplied: [],
          errors: validationResult.errors,
          warnings: validationResult.warnings
        }
      }

      // Create new version with LLM changes
      const newVersion = await this.versionManager.createVersion(
        request.artifactId,
        parsedResponse.newCode,
        `LLM Edit: ${request.editInstruction}`,
        'llm'
      )

      logger.info('Edit request completed successfully', {
        artifactId: request.artifactId,
        newVersion: newVersion.version
      })

      return {
        success: true,
        newCode: parsedResponse.newCode,
        explanation: parsedResponse.explanation,
        changesApplied: parsedResponse.changes,
        warnings: validationResult.warnings
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      logger.error('Edit request failed', { error: errorMessage, request })
      return {
        success: false,
        explanation: `Edit failed: ${errorMessage}`,
        changesApplied: [],
        errors: [errorMessage]
      }
    }
  }

  /**
   * Generate edit using LLM through AI core
   */
  private async generateEdit(prompt: string, assistant: Assistant): Promise<string> {
    try {
      if (!assistant.model) {
        throw new Error('Assistant model is required for LLM editing')
      }

      const provider = getProviderByModel(assistant.model)
      if (!provider) {
        throw new Error(`Provider not found for model: ${assistant.model.name}`)
      }

      const aiProvider = new AiProvider(provider)

      const response = await aiProvider.completions({
        assistant: {
          ...assistant,
          prompt: prompt
        },
        messages: prompt, // Use string directly as supported by the interface
        callType: 'generate', // Use generate call type for code generation
        streamOutput: false
      })

      const responseText = response.getText()
      if (!responseText) {
        throw new Error('Empty response from LLM')
      }

      return responseText
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      logger.error('LLM generation failed', { error: errorMessage })
      throw new Error(`LLM generation failed: ${errorMessage}`)
    }
  }

  /**
   * Build edit prompt for LLM
   */
  private buildEditPrompt(currentVersion: ArtifactVersion, request: EditRequest): string {
    const metadata = currentVersion.metadata || {}

    return `You are editing a React component. Here is the current code:

\`\`\`tsx
${currentVersion.code}
\`\`\`

Current component metadata:
${JSON.stringify(metadata, null, 2)}

Edit instruction: ${request.editInstruction}

${request.context ? `Additional context: ${request.context}` : ''}

Please provide the updated code following these guidelines:
1. Maintain the existing component structure unless explicitly asked to change it
2. ${request.preserveProps ? 'Preserve all existing props and their types' : 'You may modify props if needed for the requested changes'}
3. Keep the same styling approach (styled-components, inline styles, etc.)
4. Ensure the code is valid TypeScript/React
5. Add comments explaining significant changes
6. Only return the complete updated component code, no explanations outside the code

Respond with ONLY the complete updated component code wrapped in \`\`\`tsx and \`\`\` tags, followed by a brief explanation of changes made.`
  }

  /**
   * Parse LLM response to extract code and explanation
   */
  private parseEditResponse(response: string): {
    newCode?: string
    explanation: string
    changes: string[]
  } {
    try {
      // Extract code block
      const codeMatch = response.match(/```(?:tsx|typescript|jsx|javascript)?\n([\s\S]*?)\n```/)
      const newCode = codeMatch ? codeMatch[1].trim() : undefined

      // Extract explanation (everything after the code block)
      let explanation = 'Code updated successfully'
      if (codeMatch) {
        const afterCode = response.substring(response.indexOf(codeMatch[0]) + codeMatch[0].length).trim()
        if (afterCode) {
          explanation = afterCode
        }
      } else {
        explanation = response.trim()
      }

      // Extract changes from explanation
      const changes = this.extractChanges(explanation)

      return {
        newCode,
        explanation,
        changes
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      logger.error('Failed to parse LLM response', { error: errorMessage })
      return {
        explanation: 'Failed to parse LLM response',
        changes: []
      }
    }
  }

  /**
   * Extract list of changes from explanation text
   */
  private extractChanges(explanation: string): string[] {
    const changes: string[] = []

    // Look for bullet points or numbered lists
    const bulletMatches = explanation.match(/[•\-*]\s*(.+)/g)
    if (bulletMatches) {
      changes.push(...bulletMatches.map((match) => match.replace(/^[•\-*]\s*/, '').trim()))
    }

    const numberedMatches = explanation.match(/\d+\.\s*(.+)/g)
    if (numberedMatches) {
      changes.push(...numberedMatches.map((match) => match.replace(/^\d+\.\s*/, '').trim()))
    }

    // If no structured list found, try to extract sentences
    if (changes.length === 0) {
      const sentences = explanation.split(/[.!?]+/).filter((s) => s.trim().length > 10)
      changes.push(...sentences.slice(0, 3).map((s) => s.trim()))
    }

    return changes.filter((change) => change.length > 0)
  }

  /**
   * Validate generated code using compiler
   */
  private async validateCode(code: string): Promise<{
    isValid: boolean
    errors: string[]
    warnings: string[]
  }> {
    try {
      // Create a mock artifact for compilation
      const mockArtifact: ReactArtifact = {
        id: 'validation-test',
        code,
        metadata: {
          title: 'Validation Test',
          description: 'Test artifact for validation',
          props: {},
          dependencies: ['react', 'react-dom'],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        },
        version: 1,
        history: {
          artifactId: 'validation-test',
          currentVersion: 1,
          versions: []
        }
      }

      const compilationResult = await this.compiler.compileArtifact(mockArtifact, {
        generateSourceMap: false,
        minify: false
      })

      return {
        isValid: compilationResult.success,
        errors: compilationResult.errors,
        warnings: compilationResult.warnings
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      return {
        isValid: false,
        errors: [`Validation failed: ${errorMessage}`],
        warnings: []
      }
    }
  }

  /**
   * Get edit suggestions based on current artifact
   */
  public async getEditSuggestions(artifactId: string, version?: number): Promise<string[]> {
    try {
      const currentVersion = await this.versionManager.getVersion(artifactId, version || 1)
      if (!currentVersion) {
        return []
      }

      // Analyze code to suggest improvements
      const suggestions: string[] = []

      // Check for common improvement opportunities
      if (currentVersion.code.includes('useState') && !currentVersion.code.includes('useCallback')) {
        suggestions.push('Add useCallback for event handlers to optimize performance')
      }

      if (currentVersion.code.includes('map(') && !currentVersion.code.includes('key=')) {
        suggestions.push('Add proper key props to list items')
      }

      if (!currentVersion.code.includes('aria-') && currentVersion.code.includes('<button')) {
        suggestions.push('Add accessibility attributes for better screen reader support')
      }

      if (currentVersion.code.includes('style={{') && currentVersion.code.split('style={{').length > 3) {
        suggestions.push('Extract inline styles to styled-components for better maintainability')
      }

      if (!currentVersion.code.includes('PropTypes') && !currentVersion.code.includes('interface')) {
        suggestions.push('Add TypeScript interfaces or PropTypes for better type safety')
      }

      return suggestions
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      logger.error('Failed to get edit suggestions', { error: errorMessage })
      return []
    }
  }

  /**
   * Apply a predefined edit template
   */
  public async applyEditTemplate(
    artifactId: string,
    templateName: string,
    assistant: Assistant,
    options?: Record<string, any>
  ): Promise<EditResponse> {
    const templates = {
      'add-loading-state': 'Add a loading state with spinner to this component',
      'add-error-handling': 'Add comprehensive error handling and error boundaries',
      'make-responsive': 'Make this component responsive for mobile and tablet devices',
      'add-accessibility': 'Add proper ARIA labels and accessibility features',
      'optimize-performance': 'Optimize this component for better performance using React best practices',
      'add-dark-mode': 'Add dark mode support with theme switching',
      'add-animations': 'Add smooth animations and transitions to improve user experience',
      'extract-components': 'Extract reusable sub-components to improve code organization'
    }

    const instruction = templates[templateName]
    if (!instruction) {
      return {
        success: false,
        explanation: `Unknown template: ${templateName}`,
        changesApplied: [],
        errors: [`Template "${templateName}" not found`]
      }
    }

    // Get the latest version
    const history = await this.versionManager.getHistory(artifactId)
    if (!history || history.versions.length === 0) {
      return {
        success: false,
        explanation: 'Artifact not found',
        changesApplied: [],
        errors: ['Artifact not found']
      }
    }

    const editRequest: EditRequest = {
      artifactId,
      currentVersion: history.currentVersion,
      editInstruction: instruction,
      context: options ? `Template options: ${JSON.stringify(options)}` : undefined,
      preserveProps: templateName === 'optimize-performance'
    }

    return this.processEditRequest(editRequest, assistant)
  }
}
